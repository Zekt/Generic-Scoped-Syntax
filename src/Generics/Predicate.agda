module Generics.Predicate where

open import Prelude

open import Generics.Description
open import Generics.Telescope
open import ScopeSafe.Description

private variable
  rb  : RecB
  cb  : ConB
  cbs : ConBs
  ξ   : Tel ℓ
  Ty  : Set ℓ
  A B S I : Set ℓ
  Γ Δ Θ : List I

-- ≡ ⟦ [ _ ∶ Ty ] [ _ ∶ List Ty ] [] ⟧ᵗ
Indexˢ : Set ℓ → Set ℓ
Indexˢ Ty = Ty × List Ty × ⊤

Syntaxⁱ : Set ℓ → Tel ℓ' → Setω
Syntaxⁱ {ℓ} {ℓ'} Ty tel = Σω (ℓ ≡ ℓ') λ {refl → tel ≡ω [ _ ∶ Ty ] [ _ ∶ List Ty ] []}

Syntaxʳ : RecD (Indexˢ Ty) rb → List Ty → Setω
Syntaxʳ (ι (_ , Γ , tt)) Δ = Liftω (Σ[ Δ' ∈ _ ] Γ ≡ Δ' <> Δ)
Syntaxʳ (π _ _)          _ = Liftω ⊥

Syntaxᵛ : Σω[ cb ∈ _ ] ConD (Indexˢ Ty) cb → Setω
Syntaxᵛ {Ty = Ty} D = D ≡ω (_ ,ω σ[ s ∶ Ty ]
                                 σ[ Γ ∶ List Ty ]
                                 σ[ _ ∶ Var s Γ ]
                                 ι (s , Γ , tt))

-- Assume a field taken by σ has no level for now.
Syntaxᶜ : ConD (Indexˢ Ty) cb → List Ty → Setω
Syntaxᶜ (ι (_ , Γ , tt)) Δ = Liftω (Γ ≡ Δ)
Syntaxᶜ (σ {ℓ} A D)      Δ = Σω (ℓ ≡ lzero) (λ refl → (a : A) → Syntaxᶜ (D a) Δ)
Syntaxᶜ (ρ A D)          Δ = Syntaxʳ A Δ ×ωω Syntaxᶜ D Δ

Syntaxᶜˢ : ConDs (Indexˢ Ty) cbs → Setω
Syntaxᶜˢ []       = Liftω ⊤
Syntaxᶜˢ (D ∷ Ds) = Σω[ Δ ∈ _ ] Syntaxᶜ D Δ ×ωω
                      Syntaxᶜˢ Ds

Syntaxᶜˢ' : {ξ : Tel ℓ} → Set ℓ → ConDs ⟦ ξ ⟧ᵗ (cb ∷ cbs) → Setω
Syntaxᶜˢ' {ℓ = ℓ} {cb = cb} {ξ = ξ} I (D ∷ Ds) =
  Σωω (Syntaxⁱ I ξ)
      λ {(refl ,ω refl) →
         Syntaxᵛ  (cb ,ω D) ×ωω
         Syntaxᶜˢ Ds
        }

-- Conditions for syntax:
--   * No parameters
--   * Scoped index (Index consists of an `I` and a `List I`)
--   * For constructors:
--     - Recursions are not functions
--     - ... something about indices

-- Cannot define as a record due to bugs on substω₁
--record Syntax (D : D.PDataD) : Setω where
--  open D.PDataD D
--  field
--    Ty     : Set
--    Pless  : isEmpty (plevel ,ω Param)
--    Scoped : let isEmpty : Σω[ p ∈ Level ] Tel p → Setω
--                 isEmpty σ = σ ≡ω (lzero ,ω [])
--              in Σωω (isEmpty (plevel ,ω Param))
--                     λ { refl →
--                         Σωω (Syntaxⁱ (ilevel ,ω Index tt))
--                             λ { (fstω₁ ,ω sndω₁) →
--                                 {!!}}
--                       }

Syntax : Set ℓ → PDataD → Setω
Syntax {ℓ} Ty PD =
  Σωω Scoped
      λ { (refl ,ω refl ,ωω refl ,ω prf) →
             Σω[ Δ ∈ List Ty ]
            Σωω[ (cb' ,ω cbs' ,ω D' ,ωω Ds')
                   ∈ SyntaxConDs ⟦ Index tt ⟧ᵗ ]
            Σω (struct ≡ (cb' ∷ cbs'))
               (λ {refl → applyP tt ≡ω (D' ∷ Ds')})
            ×ωω Syntaxᶜˢ' ⟦ Index tt ⟧ᵗ (D' ∷ Ds')
        }
  where
    open PDataD PD
    SyntaxConDs : Set ℓ → Setω
    SyntaxConDs X =  Σω[ cb  ∈ ConB      ]
                     Σω[ cbs ∈ ConBs     ]
                    Σωω[ D   ∈ ConD X cb ]
                      ConDs X cbs
    Scoped : Setω
    Scoped = Σω (plevel ≡ lzero) (λ {refl →
                Σωω (Param ≡ω []) (λ {refl →
                  Syntaxⁱ {ℓ} {ilevel} Ty (Index tt)
                })
              })

-- A possibly better (or worse) way to handle equalities
--    Scoped : Setω
--    Scoped = _≡ω_ {Σω[ p ∈ Level ]
--                   Σω[ i ∈ Level ]
--                   Σωω[ Par ∈ Tel p ] (⟦ Par ⟧ᵗ → Tel i)}
--                  (plevel ,ω ilevel ,ω Param ,ωω Index)
--                  (lzero  ,ω lzero  ,ω []    ,ωω λ {tt → [ _ ∶ Ty ] [ _ ∶ List Ty ] []})

Syntaxᵈ : Set ℓ → DataD → Setω
Syntaxᵈ Ty D = Σω (DataD.#levels D ≡ 0)
                  λ {refl → Syntax Ty (DataD.applyL D tt)}

toDescᶜ : (D : ConD (Indexˢ I) cb) → Syntaxᶜ D Γ → Desc' I
toDescᶜ (ι (t , ts , tt)) (lift refl) = `▪ t
toDescᶜ (σ A D) (refl ,ω Sy) = `σ (Lift _ A) λ {(lift a) → toDescᶜ (D a) (Sy a)}
toDescᶜ (ρ (ι (i , _ , tt)) D) (lift (is_ , refl) ,ωω prfᶜ) = `X is_ i (toDescᶜ D prfᶜ)

-- Fin can be used here
open import Prelude.Fin
private
  lengthᴰ : ConDs I cbs → ℕ
  lengthᴰ []       = 0
  lengthᴰ (D ∷ Ds) = suc (lengthᴰ Ds)

toDescᶜˢ : (Ds : ConDs (Indexˢ I) cbs) → Syntaxᶜˢ Ds → Desc' I
toDescᶜˢ [] _ = `σ (Lift _ ⊥) λ ()
toDescᶜˢ (D ∷ Ds) (Γ ,ω Syᶜ ,ωω Syᶜˢ) with lengthᴰ Ds
... | n = `σ (Lift _ (Fin n))
             λ { (lift zero)    → toDescᶜ D Syᶜ
               ; (lift (suc m)) → toDescᶜˢ Ds Syᶜˢ}

-- Ignore (but still require) the first constructor taking Var,
-- since the variable case is freely generated by the generic programs
toDesc : {ξ : Tel ℓ}
       → (Ds : ConDs ⟦ ξ ⟧ᵗ (cb ∷ cbs))
       → Syntaxᶜˢ' I Ds
       → Desc' I
toDesc (D ∷ Ds) ((refl ,ω refl) ,ωω Syᵛ ,ωω Syᶜˢ) = toDescᶜˢ Ds Syᶜˢ

{-- Cursed attempt of conversion
toDescᵈ : (D : D.DataD) → Σω[ Ty ∈ Set ] Syntaxᵈ Ty D → Σ[ I ∈ Set ] Desc' I
toDescᵈ D (Ty ,ω refl ,ω (a ,ω b) ,ωω f) with D.DataD.applyL D tt
toDescᵈ .(D.datad _ _) (Ty
                      ,ω  refl
                      ,ω  (refl ,ω refl ,ωω refl ,ω prf)
                      ,ωω Δ
                      ,ω  (_ ,ω _ ,ω D' ,ωω Ds')
                      ,ωω (refl ,ω cds≡)
                      ,ωω Synᵛ
                      ,ωω Synᶜˢ)
     | D.pdatad alevel .[] Index applyP with applyP tt
toDescᵈ .(D.datad _ _)
       (Ty
         ,ω  refl
         ,ω  (refl ,ω refl ,ωω refl ,ω prf)
         ,ωω Δ
         ,ω  (_ ,ω _ ,ω .D ,ωω .Ds)
         ,ωω (refl ,ω refl)
         ,ωω Synᵛ
         ,ωω Synᶜˢ)
     | D.pdatad alevel .[] Index applyP | (D D.∷ Ds) = Ty , {!!}
--}
